#ifndef MPOINTER_H
#define MPOINTER_H

#include <iostream>

template <typename T>
class MPointer {
private:
	T* ptr;  // Puntero que encapsularemos
	
public:
	// Constructor: Inicializa el puntero, reservando memoria
	MPointer() {
		ptr = new T();  // Reserva memoria para el tipo T
		std::cout << "MPointer creado y memoria reservada." << std::endl;
	}
	
	// Destructor: Libera la memoria reservada
	~MPointer() {
		delete ptr;  // Libera la memoria
		std::cout << "MPointer destruido y memoria liberada." << std::endl;
	}
	
	// Sobrecarga del operador * (dereference) para obtener o asignar valor
	T& operator*() {
		return *ptr;  // Devuelve el valor apuntado
	}
	
	// Sobrecarga del operador & para obtener la dirección del puntero
	T* operator&() {
		return ptr;  // Devuelve la dirección del puntero encapsulado
	}
	
	// Sobrecarga del operador de asignación
	MPointer<T>& operator=(const MPointer<T>& other) {
		if (this != &other) {  // Evitar auto-asignación
			delete ptr;  // Libera la memoria actual
			ptr = new T(*other.ptr);  // Asigna una nueva copia
		}
		return *this;
	}
	
	// Método estático para crear un nuevo MPointer
	static MPointer<T> New() {
		return MPointer<T>();  // Llama al constructor por defecto
	}
};

#endif
